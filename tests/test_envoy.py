"""
Tests for the Envoy proxy configuration.
"""

import pytest
import subprocess
import yaml
from pathlib import Path


class TestEnvoyConfig:
    """Test Envoy configuration validity."""

    def test_envoy_config_exists(self, configs_dir):
        """Envoy config file should exist."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        assert config_file.exists(), f"Envoy config not found at {config_file}"

    def test_envoy_config_valid_yaml(self, configs_dir):
        """Envoy config should be valid YAML."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        content = config_file.read_text()

        try:
            config = yaml.safe_load(content)
            assert config is not None
        except yaml.YAMLError as e:
            pytest.fail(f"Invalid YAML: {e}")

    def test_envoy_config_has_listeners(self, configs_dir):
        """Envoy config should define listeners."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        config = yaml.safe_load(config_file.read_text())

        assert "static_resources" in config
        assert "listeners" in config["static_resources"]
        assert len(config["static_resources"]["listeners"]) > 0

    def test_envoy_config_has_clusters(self, configs_dir):
        """Envoy config should define clusters."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        config = yaml.safe_load(config_file.read_text())

        assert "static_resources" in config
        assert "clusters" in config["static_resources"]

    def test_envoy_config_has_admin(self, configs_dir):
        """Envoy config should have admin interface."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        config = yaml.safe_load(config_file.read_text())

        assert "admin" in config
        assert "address" in config["admin"]

    def test_envoy_config_no_lua_filter(self, configs_dir):
        """Envoy config should not contain any Lua filter references."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        content = config_file.read_text()
        assert "lua" not in content.lower() or "lua" in "failure", \
            "Envoy config should not reference Lua filters"

    def test_envoy_config_has_local_ratelimit(self, configs_dir):
        """Envoy static config should have local_ratelimit filter."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        content = config_file.read_text()
        assert "envoy.filters.http.local_ratelimit" in content, \
            "Envoy config should have local_ratelimit filter"


class TestEnvoyProxySettings:
    """Test Envoy proxy configuration settings."""

    def test_proxy_listens_on_expected_port(self, configs_dir):
        """Envoy should listen on the expected proxy port."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        config = yaml.safe_load(config_file.read_text())

        listeners = config["static_resources"]["listeners"]

        # Find the main proxy listener
        proxy_ports = []
        for listener in listeners:
            address = listener.get("address", {})
            socket_address = address.get("socket_address", {})
            port = socket_address.get("port_value")
            if port:
                proxy_ports.append(port)

        # Should have at least one listener
        assert len(proxy_ports) > 0, "No listener ports found"

    def test_proxy_has_access_logging(self, configs_dir):
        """Envoy should have access logging configured."""
        config_file = configs_dir / "envoy" / "envoy-enhanced.yaml"
        content = config_file.read_text()

        # Check for access log configuration
        assert "access_log" in content.lower() or "accesslog" in content.lower(), \
            "Envoy should have access logging configured"


class TestEnvoyNativeFilters:
    """Test native Envoy filter configuration generated by config_generator."""

    def _generate_config(self, configs_dir):
        """Generate Envoy config from cagent.yaml for testing."""
        import sys
        sys.path.insert(0, str(configs_dir.parent / "services" / "warden"))
        from config_generator import ConfigGenerator

        gen = ConfigGenerator(str(configs_dir / "cagent.yaml"))
        gen.load_config()
        return gen.generate_envoy_config()

    def test_envoy_config_has_ext_authz(self, configs_dir):
        """Generated config should have ext_authz filter."""
        config = self._generate_config(configs_dir)
        listeners = config["static_resources"]["listeners"]
        http_filters = listeners[0]["filter_chains"][0]["filters"][0]["typed_config"]["http_filters"]

        filter_names = [f["name"] for f in http_filters]
        assert "envoy.filters.http.ext_authz" in filter_names, \
            "Generated config should have ext_authz filter"

    def test_envoy_config_has_local_ratelimit(self, configs_dir):
        """Generated config should have local_ratelimit filter."""
        config = self._generate_config(configs_dir)
        listeners = config["static_resources"]["listeners"]
        http_filters = listeners[0]["filter_chains"][0]["filters"][0]["typed_config"]["http_filters"]

        filter_names = [f["name"] for f in http_filters]
        assert "envoy.filters.http.local_ratelimit" in filter_names, \
            "Generated config should have local_ratelimit filter"

    def test_envoy_config_no_lua_filter(self, configs_dir):
        """Generated config should not have Lua filter."""
        config = self._generate_config(configs_dir)
        listeners = config["static_resources"]["listeners"]
        http_filters = listeners[0]["filter_chains"][0]["filters"][0]["typed_config"]["http_filters"]

        filter_names = [f["name"] for f in http_filters]
        assert "envoy.filters.http.lua" not in filter_names, \
            "Generated config should not have Lua filter"

    def test_envoy_config_has_rate_limit_per_route(self, configs_dir):
        """Generated config should have per-route rate limit for domains with custom rate limits."""
        config = self._generate_config(configs_dir)
        listeners = config["static_resources"]["listeners"]
        virtual_hosts = listeners[0]["filter_chains"][0]["filters"][0]["typed_config"]["route_config"]["virtual_hosts"]

        # Find a virtual host with a domain that has custom rate limits (e.g., api.openai.com)
        found_per_route_rl = False
        for vhost in virtual_hosts:
            for route in vhost.get("routes", []):
                tpfc = route.get("typed_per_filter_config", {})
                if "envoy.filters.http.local_ratelimit" in tpfc:
                    found_per_route_rl = True
                    rl_config = tpfc["envoy.filters.http.local_ratelimit"]
                    assert "token_bucket" in rl_config
                    assert "max_tokens" in rl_config["token_bucket"]
                    break
            if found_per_route_rl:
                break

        assert found_per_route_rl, \
            "Should have at least one route with per-route rate limit config"

    def test_envoy_config_ext_authz_has_credential_headers(self, configs_dir):
        """ext_authz filter should allow credential headers upstream."""
        config = self._generate_config(configs_dir)
        listeners = config["static_resources"]["listeners"]
        http_filters = listeners[0]["filter_chains"][0]["filters"][0]["typed_config"]["http_filters"]

        ext_authz = None
        for f in http_filters:
            if f["name"] == "envoy.filters.http.ext_authz":
                ext_authz = f
                break

        assert ext_authz is not None
        tc = ext_authz["typed_config"]
        assert tc["failure_mode_allow"] is True
        patterns = tc["http_service"]["authorization_response"]["allowed_upstream_headers"]["patterns"]
        header_names = [p["exact"] for p in patterns]
        assert "authorization" in header_names
        assert "x-credential-injected" in header_names

    def test_envoy_config_routes_have_tracking_headers(self, configs_dir):
        """Routes should have X-Real-Domain tracking header."""
        config = self._generate_config(configs_dir)
        listeners = config["static_resources"]["listeners"]
        virtual_hosts = listeners[0]["filter_chains"][0]["filters"][0]["typed_config"]["route_config"]["virtual_hosts"]

        found_tracking = False
        for vhost in virtual_hosts:
            for route in vhost.get("routes", []):
                headers_to_add = route.get("request_headers_to_add", [])
                for h in headers_to_add:
                    if h.get("header", {}).get("key") == "X-Real-Domain":
                        found_tracking = True
                        break
                if found_tracking:
                    break
            if found_tracking:
                break

        assert found_tracking, "Should have X-Real-Domain tracking header on at least one route"

    def test_rpm_to_token_bucket(self, configs_dir):
        """_rpm_to_token_bucket should correctly convert RPM to token bucket config."""
        import sys
        sys.path.insert(0, str(configs_dir.parent / "services" / "warden"))
        from config_generator import ConfigGenerator

        # rpm >= 60: tokens_per_fill = rpm // 60, fill_interval = 1s
        result = ConfigGenerator._rpm_to_token_bucket(120, 20)
        assert result == {'max_tokens': 20, 'tokens_per_fill': 2, 'fill_interval': '1s'}

        result = ConfigGenerator._rpm_to_token_bucket(60, 10)
        assert result == {'max_tokens': 10, 'tokens_per_fill': 1, 'fill_interval': '1s'}

        # rpm < 60: tokens_per_fill = 1, fill_interval = {60 // rpm}s
        result = ConfigGenerator._rpm_to_token_bucket(30, 5)
        assert result == {'max_tokens': 5, 'tokens_per_fill': 1, 'fill_interval': '2s'}

        result = ConfigGenerator._rpm_to_token_bucket(10, 3)
        assert result == {'max_tokens': 3, 'tokens_per_fill': 1, 'fill_interval': '6s'}
