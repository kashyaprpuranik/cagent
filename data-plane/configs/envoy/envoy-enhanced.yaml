# =============================================================================
# Envoy Proxy Configuration - Enhanced
# Features: DNS filtering, request/response logging, credential injection
# =============================================================================

admin:
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 9901

static_resources:
  listeners:
    # =========================================================================
    # DNS Proxy Listener (UDP 53)
    # Filters DNS queries to only allow approved domains
    # =========================================================================
    - name: dns_listener
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 53
          protocol: UDP
      listener_filters:
        - name: envoy.filters.udp_listener.udp_proxy
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig
            stat_prefix: dns
            matcher:
              on_no_match:
                action:
                  name: route
                  typed_config:
                    "@type": type.googleapis.com/envoy.extensions.filters.udp.udp_proxy.v3.Route
                    cluster: dns_upstream
            # DNS filtering is handled by external filter or upstream

    # =========================================================================
    # HTTPS Egress Listener with Full Logging
    # =========================================================================
    - name: egress_https
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8443
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: egress_https
                codec_type: AUTO

                # Access logging - JSON to stdout
                access_log:
                  - name: envoy.access_loggers.stdout
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
                      log_format:
                        json_format:
                          timestamp: "%START_TIME%"
                          authority: "%REQ(:AUTHORITY)%"
                          real_domain: "%REQ(X-REAL-DOMAIN)%"
                          path: "%REQ(:PATH)%"
                          method: "%REQ(:METHOD)%"
                          response_code: "%RESPONSE_CODE%"
                          response_flags: "%RESPONSE_FLAGS%"
                          credential_injected: "%REQ(X-CREDENTIAL-INJECTED)%"
                          rate_limited: "%REQ(X-RATE-LIMITED)%"
                          duration_ms: "%DURATION%"
                          bytes_received: "%BYTES_RECEIVED%"
                          bytes_sent: "%BYTES_SENT%"
                          upstream_cluster: "%UPSTREAM_CLUSTER%"
                          user_agent: "%REQ(USER-AGENT)%"
                          downstream_remote_address: "%DOWNSTREAM_REMOTE_ADDRESS%"

                route_config:
                  name: egress_routes
                  virtual_hosts:
                    # ---------------------------------------------------------
                    # GitHub API
                    # ---------------------------------------------------------
                    - name: github_api
                      domains:
                        - "api.github.com"
                        - "api.github.com:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: github_api
                            timeout: 30s
                          request_headers_to_add:
                            - header:
                                key: "X-Source"
                                value: "ai-devbox"

                    # ---------------------------------------------------------
                    # PyPI - Read only
                    # ---------------------------------------------------------
                    - name: pypi
                      domains:
                        - "pypi.org"
                        - "pypi.org:443"
                        - "files.pythonhosted.org"
                        - "files.pythonhosted.org:443"
                      routes:
                        # Block POST/PUT/DELETE (no uploads)
                        - match:
                            prefix: "/"
                            headers:
                              - name: ":method"
                                string_match:
                                  exact: "POST"
                          direct_response:
                            status: 403
                            body:
                              inline_string: "Upload to PyPI not allowed"
                        - match:
                            prefix: "/"
                            headers:
                              - name: ":method"
                                string_match:
                                  exact: "PUT"
                          direct_response:
                            status: 403
                            body:
                              inline_string: "Upload to PyPI not allowed"
                        # Allow GET
                        - match:
                            prefix: "/"
                          route:
                            cluster: pypi
                            timeout: 60s

                    # ---------------------------------------------------------
                    # HuggingFace
                    # ---------------------------------------------------------
                    - name: huggingface
                      domains:
                        - "huggingface.co"
                        - "huggingface.co:443"
                        - "*.huggingface.co"
                        - "*.huggingface.co:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: huggingface
                            timeout: 300s  # Large model downloads
                            max_stream_duration:
                              max_stream_duration: 600s

                    # ---------------------------------------------------------
                    # OpenAI API
                    # ---------------------------------------------------------
                    - name: openai
                      domains:
                        - "api.openai.com"
                        - "api.openai.com:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: openai_api
                            timeout: 120s

                    # ---------------------------------------------------------
                    # Anthropic API
                    # ---------------------------------------------------------
                    - name: anthropic
                      domains:
                        - "api.anthropic.com"
                        - "api.anthropic.com:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: anthropic_api
                            timeout: 120s

                    # ---------------------------------------------------------
                    # Devbox Local - HTTP to HTTPS upgrade with credentials
                    # Agent uses: curl http://api-openai-com.devbox.local/...
                    # Envoy upgrades to HTTPS and injects credentials
                    # ---------------------------------------------------------
                    - name: devbox_openai
                      domains:
                        - "api-openai-com.devbox.local"
                        - "api-openai-com.devbox.local:*"
                        - "openai.devbox.local"
                        - "openai.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: openai_api
                            timeout: 120s
                            auto_host_rewrite: true

                    - name: devbox_anthropic
                      domains:
                        - "api-anthropic-com.devbox.local"
                        - "api-anthropic-com.devbox.local:*"
                        - "anthropic.devbox.local"
                        - "anthropic.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: anthropic_api
                            timeout: 120s
                            auto_host_rewrite: true

                    - name: devbox_github
                      domains:
                        - "api-github-com.devbox.local"
                        - "api-github-com.devbox.local:*"
                        - "github.devbox.local"
                        - "github.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: github_api
                            timeout: 30s
                            auto_host_rewrite: true

                    - name: devbox_huggingface
                      domains:
                        - "huggingface-co.devbox.local"
                        - "huggingface-co.devbox.local:*"
                        - "huggingface.devbox.local"
                        - "huggingface.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: huggingface
                            timeout: 300s
                            auto_host_rewrite: true

                    # ---------------------------------------------------------
                    # Catch-all - Block with logging
                    # ---------------------------------------------------------
                    - name: blocked
                      domains:
                        - "*"
                      routes:
                        - match:
                            prefix: "/"
                          direct_response:
                            status: 403
                            body:
                              inline_string: '{"error": "destination_not_allowed", "message": "This domain is not in the allowlist"}'

                http_filters:
                  # ---------------------------------------------------------
                  # Request/Response Body Logging (Tap)
                  # ---------------------------------------------------------
                  - name: envoy.filters.http.tap
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.tap.v3.Tap
                      common_config:
                        static_config:
                          match_config:
                            any_match: true
                          output_config:
                            sinks:
                              - file_per_tap:
                                  path_prefix: /var/log/envoy/tap/
                            max_buffered_rx_bytes: 10240  # 10KB request body
                            max_buffered_tx_bytes: 10240  # 10KB response body
                            streaming: false

                  # ---------------------------------------------------------
                  # Lua Filter - Credential Injection + Rate Limiting + Security
                  # ---------------------------------------------------------
                  - name: envoy.filters.http.lua
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                      inline_code: |
                        -- =======================================================================
                        -- Configuration
                        -- =======================================================================
                        -- Mode: "standalone" = no control plane, "connected" = use CP with fallback
                        local DATAPLANE_MODE = os.getenv("DATAPLANE_MODE") or "connected"
                        local API_TOKEN = os.getenv("CONTROL_PLANE_TOKEN") or os.getenv("API_TOKEN") or ""
                        local CACHE_TTL_SECONDS = 300  -- 5 minutes
                        local CP_FAILURE_BACKOFF = 30  -- Seconds to wait before retrying CP after failure

                        -- Caches
                        local credential_cache = {}  -- domain -> {header_name, header_value, expires_at}
                        local rate_limit_cache = {}  -- domain -> {rpm, burst, expires_at}
                        local token_buckets = {}     -- domain -> {tokens, last_refill}

                        -- Devbox.local to real domain mapping
                        local devbox_domain_map = {}
                        local domain_map_expires_at = 0

                        -- Control plane health tracking
                        local cp_available = true
                        local cp_last_failure = 0

                        -- =======================================================================
                        -- Static Configuration (loaded from environment)
                        -- Format: STATIC_DOMAIN_MAP="openai.devbox.local:api.openai.com,github.devbox.local:api.github.com"
                        -- Format: STATIC_CREDENTIALS="api.openai.com:Authorization:Bearer sk-xxx"
                        -- Format: STATIC_RATE_LIMITS="api.openai.com:60:10,default:120:20"
                        -- =======================================================================
                        local static_credentials = {}
                        local static_rate_limits = {}
                        local static_domain_map = {}
                        local static_config_loaded = false

                        function load_static_config(request_handle)
                          if static_config_loaded then return end
                          static_config_loaded = true

                          -- Load static domain mappings
                          local domain_map_env = os.getenv("STATIC_DOMAIN_MAP") or ""
                          for mapping in string.gmatch(domain_map_env, "[^,]+") do
                            local alias, domain = string.match(mapping, "([^:]+):(.+)")
                            if alias and domain then
                              static_domain_map[alias] = domain
                              request_handle:logInfo("Static mapping: " .. alias .. " -> " .. domain)
                            end
                          end

                          -- Load static credentials
                          local creds_env = os.getenv("STATIC_CREDENTIALS") or ""
                          for cred in string.gmatch(creds_env, "[^|]+") do
                            local domain, header_name, header_value = string.match(cred, "([^:]+):([^:]+):(.+)")
                            if domain and header_name and header_value then
                              static_credentials[domain] = {
                                header_name = header_name,
                                header_value = header_value
                              }
                              request_handle:logInfo("Static credential loaded for: " .. domain)
                            end
                          end

                          -- Load static rate limits (domain:rpm:burst)
                          local limits_env = os.getenv("STATIC_RATE_LIMITS") or ""
                          for limit in string.gmatch(limits_env, "[^,]+") do
                            local domain, rpm, burst = string.match(limit, "([^:]+):(%d+):(%d+)")
                            if domain and rpm then
                              static_rate_limits[domain] = {
                                requests_per_minute = tonumber(rpm),
                                burst_size = tonumber(burst) or 10
                              }
                              request_handle:logInfo("Static rate limit for " .. domain .. ": " .. rpm .. " rpm")
                            end
                          end

                          -- Default rate limit if not specified
                          if not static_rate_limits["default"] then
                            static_rate_limits["default"] = {
                              requests_per_minute = 120,
                              burst_size = 20
                            }
                          end
                        end

                        -- Check if control plane should be contacted
                        function should_contact_cp()
                          if DATAPLANE_MODE == "standalone" then
                            return false
                          end
                          if API_TOKEN == "" then
                            return false
                          end
                          -- Backoff after failure
                          if not cp_available and (os.time() - cp_last_failure) < CP_FAILURE_BACKOFF then
                            return false
                          end
                          return true
                        end

                        -- Mark CP as failed (for backoff)
                        function mark_cp_failure()
                          cp_available = false
                          cp_last_failure = os.time()
                        end

                        -- Mark CP as available
                        function mark_cp_success()
                          cp_available = true
                        end

                        -- Fetch domain mappings from control plane API
                        function refresh_domain_mappings(request_handle)
                          load_static_config(request_handle)

                          local now = os.time()
                          if now < domain_map_expires_at then
                            return  -- Cache still valid
                          end

                          -- Merge static mappings first
                          for alias, domain in pairs(static_domain_map) do
                            devbox_domain_map[alias] = domain
                          end

                          if not should_contact_cp() then
                            domain_map_expires_at = now + CACHE_TTL_SECONDS
                            return
                          end

                          request_handle:logInfo("Fetching domain mappings from control plane")

                          local headers, body = request_handle:httpCall(
                            "control_plane_api",
                            {
                              [":method"] = "GET",
                              [":path"] = "/api/v1/domain-mappings",
                              [":authority"] = "control-plane-api",
                              ["authorization"] = "Bearer " .. API_TOKEN
                            },
                            "",
                            5000,
                            false
                          )

                          if body and string.len(body) > 0 then
                            mark_cp_success()
                            -- Parse mappings from JSON response (CP overrides static)
                            for alias, domain in string.gmatch(body, '"([^"]+%.devbox%.local)"%s*:%s*"([^"]+)"') do
                              devbox_domain_map[alias] = domain
                              request_handle:logInfo("CP mapping: " .. alias .. " -> " .. domain)
                            end
                          else
                            mark_cp_failure()
                            request_handle:logWarn("Control plane unavailable, using static config")
                          end

                          domain_map_expires_at = now + CACHE_TTL_SECONDS
                        end

                        -- Map devbox.local host to real domain for credential lookup
                        function get_real_domain(request_handle, host)
                          local host_clean = string.match(host, "^([^:]+)") or host

                          -- Check if this looks like a devbox.local request
                          if string.match(host_clean, "%.devbox%.local$") then
                            -- Refresh mappings if needed
                            refresh_domain_mappings(request_handle)

                            local mapped = devbox_domain_map[host_clean]
                            if mapped then
                              return mapped, true  -- mapped domain, is_devbox_local
                            end
                            -- Unknown devbox.local alias - return as-is
                            request_handle:logWarn("Unknown devbox.local alias: " .. host_clean)
                          end

                          return host_clean, false
                        end

                        -- DNS Tunneling Detection
                        function detect_dns_tunneling(host)
                          local parts = {}
                          for part in string.gmatch(host, "[^%.]+") do
                            table.insert(parts, part)
                          end

                          for _, part in ipairs(parts) do
                            if string.len(part) > 63 then
                              return true, "Subdomain exceeds 63 characters"
                            end
                          end

                          if string.len(host) > 100 then
                            return true, "Hostname unusually long"
                          end

                          return false, nil
                        end

                        -- URL encode for query params
                        function url_encode(str)
                          if str then
                            str = string.gsub(str, "([^%w%-%.%_%~])", function(c)
                              return string.format("%%%02X", string.byte(c))
                            end)
                          end
                          return str
                        end

                        -- Simple JSON parser for credential response
                        function parse_credential_response(body)
                          if not body or body == "" then
                            return nil
                          end

                          local matched = string.match(body, '"matched"%s*:%s*true')
                          if not matched then
                            return nil
                          end

                          local header_name = string.match(body, '"header_name"%s*:%s*"([^"]+)"')
                          local header_value = string.match(body, '"header_value"%s*:%s*"([^"]+)"')

                          if header_name and header_value then
                            return {
                              header_name = header_name,
                              header_value = header_value
                            }
                          end

                          return nil
                        end

                        -- Parse rate limit response
                        function parse_rate_limit_response(body)
                          if not body or body == "" then
                            return nil
                          end

                          local rpm = string.match(body, '"requests_per_minute"%s*:%s*(%d+)')
                          local burst = string.match(body, '"burst_size"%s*:%s*(%d+)')

                          if rpm then
                            return {
                              requests_per_minute = tonumber(rpm),
                              burst_size = tonumber(burst) or 10
                            }
                          end

                          return nil
                        end

                        -- Get credential for domain (with caching, static fallback)
                        function get_credential(request_handle, domain)
                          load_static_config(request_handle)
                          local host_clean = string.match(domain, "^([^:]+)") or domain

                          local cached = credential_cache[host_clean]
                          if cached and cached.expires_at > os.time() then
                            return cached
                          end

                          local cred = nil

                          -- Try control plane first (if available)
                          if should_contact_cp() then
                            local headers, body = request_handle:httpCall(
                              "control_plane_api",
                              {
                                [":method"] = "GET",
                                [":path"] = "/api/v1/secrets/for-domain?domain=" .. url_encode(host_clean),
                                [":authority"] = "control-plane-api",
                                ["authorization"] = "Bearer " .. API_TOKEN
                              },
                              "",
                              5000,
                              false
                            )

                            if body and string.len(body) > 0 then
                              mark_cp_success()
                              cred = parse_credential_response(body)
                            else
                              mark_cp_failure()
                              request_handle:logWarn("CP unavailable for credential lookup: " .. host_clean)
                            end
                          end

                          -- Fall back to static credentials
                          if not cred then
                            cred = static_credentials[host_clean]
                            -- Try wildcard match (*.domain.com)
                            if not cred then
                              for pattern, static_cred in pairs(static_credentials) do
                                if string.sub(pattern, 1, 2) == "*." then
                                  local suffix = string.sub(pattern, 2)  -- .domain.com
                                  if string.sub(host_clean, -string.len(suffix)) == suffix then
                                    cred = static_cred
                                    break
                                  end
                                end
                              end
                            end
                          end

                          if cred then
                            cred.expires_at = os.time() + CACHE_TTL_SECONDS
                            credential_cache[host_clean] = cred
                          else
                            -- Cache negative result briefly
                            credential_cache[host_clean] = { expires_at = os.time() + 60 }
                          end

                          return cred
                        end

                        -- Get rate limit config for domain (with caching, static fallback)
                        function get_rate_limit_config(request_handle, domain)
                          load_static_config(request_handle)
                          local host_clean = string.match(domain, "^([^:]+)") or domain

                          local cached = rate_limit_cache[host_clean]
                          if cached and cached.expires_at > os.time() then
                            return cached
                          end

                          local config = nil

                          -- Try control plane first (if available)
                          if should_contact_cp() then
                            local headers, body = request_handle:httpCall(
                              "control_plane_api",
                              {
                                [":method"] = "GET",
                                [":path"] = "/api/v1/rate-limits/for-domain?domain=" .. url_encode(host_clean),
                                [":authority"] = "control-plane-api",
                                ["authorization"] = "Bearer " .. API_TOKEN
                              },
                              "",
                              5000,
                              false
                            )

                            if body and string.len(body) > 0 then
                              mark_cp_success()
                              config = parse_rate_limit_response(body)
                            else
                              mark_cp_failure()
                            end
                          end

                          -- Fall back to static rate limits
                          if not config then
                            config = static_rate_limits[host_clean]
                            -- Try wildcard match
                            if not config then
                              for pattern, static_limit in pairs(static_rate_limits) do
                                if string.sub(pattern, 1, 2) == "*." then
                                  local suffix = string.sub(pattern, 2)
                                  if string.sub(host_clean, -string.len(suffix)) == suffix then
                                    config = static_limit
                                    break
                                  end
                                end
                              end
                            end
                            -- Use default
                            if not config then
                              config = static_rate_limits["default"] or {
                                requests_per_minute = 120,
                                burst_size = 20
                              }
                            end
                          end

                          config.expires_at = os.time() + CACHE_TTL_SECONDS
                          rate_limit_cache[host_clean] = config

                          return config
                        end

                        -- Token bucket rate limiter
                        function check_rate_limit(request_handle, domain)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local config = get_rate_limit_config(request_handle, host_clean)

                          if not config then
                            return true  -- Allow if no config
                          end

                          local now = os.time()
                          local bucket = token_buckets[host_clean]

                          if not bucket then
                            -- Initialize bucket
                            bucket = {
                              tokens = config.burst_size,
                              last_refill = now
                            }
                            token_buckets[host_clean] = bucket
                          end

                          -- Refill tokens based on time elapsed
                          local elapsed = now - bucket.last_refill
                          local tokens_per_second = config.requests_per_minute / 60.0
                          local new_tokens = elapsed * tokens_per_second
                          bucket.tokens = math.min(config.burst_size, bucket.tokens + new_tokens)
                          bucket.last_refill = now

                          -- Try to consume a token
                          if bucket.tokens >= 1 then
                            bucket.tokens = bucket.tokens - 1
                            return true
                          end

                          request_handle:logWarn(string.format(
                            "Rate limit exceeded for %s (limit: %d rpm)",
                            host_clean, config.requests_per_minute
                          ))
                          return false
                        end

                        function envoy_on_request(request_handle)
                          local host = request_handle:headers():get(":authority") or ""
                          local credential_injected = "false"
                          local rate_limited = "false"
                          local is_devbox_local = false

                          -- Map devbox.local to real domain for credential/rate-limit lookup
                          local real_domain
                          real_domain, is_devbox_local = get_real_domain(request_handle, host)

                          -- Skip DNS tunneling check for devbox.local (it's internal)
                          if not is_devbox_local then
                            local is_suspicious, reason = detect_dns_tunneling(host)
                            if is_suspicious then
                              request_handle:logWarn("Potential DNS tunneling: " .. host .. " - " .. reason)
                              request_handle:respond(
                                {[":status"] = "403"},
                                "Request blocked: suspicious hostname pattern"
                              )
                              return
                            end
                          end

                          -- Rate limiting (use real domain for lookup)
                          if not check_rate_limit(request_handle, real_domain) then
                            rate_limited = "true"
                            request_handle:headers():add("X-Rate-Limited", rate_limited)
                            request_handle:respond(
                              {[":status"] = "429", ["retry-after"] = "60"},
                              '{"error": "rate_limit_exceeded", "message": "Too many requests to this domain"}'
                            )
                            return
                          end

                          -- Credential injection (use real domain for lookup)
                          local cred = get_credential(request_handle, real_domain)
                          if cred and cred.header_name and cred.header_value then
                            request_handle:headers():remove(cred.header_name)
                            request_handle:headers():add(cred.header_name, cred.header_value)
                            credential_injected = "true"
                            request_handle:logInfo(string.format(
                              "Injected credential for %s (via %s): %s",
                              real_domain, host, cred.header_name
                            ))
                          end

                          -- Add tracking headers for access log
                          request_handle:headers():add("X-Credential-Injected", credential_injected)
                          request_handle:headers():add("X-Rate-Limited", rate_limited)
                          request_handle:headers():add("X-Real-Domain", real_domain)
                          request_handle:headers():add("X-Devbox-Timestamp", os.date("!%Y-%m-%dT%H:%M:%SZ"))

                          if is_devbox_local then
                            request_handle:logInfo(string.format(
                              "Devbox proxy: %s -> %s (credential_injected=%s)",
                              host, real_domain, credential_injected
                            ))
                          end
                        end

                        function envoy_on_response(response_handle)
                          local status = response_handle:headers():get(":status")
                          local content_length = response_handle:headers():get("content-length") or "unknown"

                          response_handle:logInfo(string.format(
                            "RESPONSE: status=%s content_length=%s",
                            status, content_length
                          ))
                        end

                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    # =========================================================================
    # Control Plane API (for credential lookup)
    # =========================================================================
    - name: control_plane_api
      type: STRICT_DNS
      connect_timeout: 5s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: control_plane_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: control-plane-api
                      port_value: 8002

    # =========================================================================
    # DNS Upstream (Filtered)
    # =========================================================================
    - name: dns_upstream
      type: STRICT_DNS
      connect_timeout: 2s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: dns_upstream
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: 8.8.8.8
                      port_value: 53

    # =========================================================================
    # External Service Clusters
    # =========================================================================
    - name: github_api
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 100
            max_pending_requests: 100
            max_requests: 100
            max_retries: 3
      load_assignment:
        cluster_name: github_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: api.github.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: api.github.com

    - name: pypi
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 50
            max_pending_requests: 50
            max_requests: 100
      load_assignment:
        cluster_name: pypi
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: pypi.org
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: pypi.org

    - name: huggingface
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 20
            max_pending_requests: 10
            max_requests: 30
      load_assignment:
        cluster_name: huggingface
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: huggingface.co
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: huggingface.co

    - name: openai_api
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 50
            max_pending_requests: 100
            max_requests: 60
      load_assignment:
        cluster_name: openai_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: api.openai.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: api.openai.com

    - name: anthropic_api
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 50
            max_pending_requests: 100
            max_requests: 60
      load_assignment:
        cluster_name: anthropic_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: api.anthropic.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: api.anthropic.com

layered_runtime:
  layers:
    - name: static_layer
      static_layer:
        envoy:
          resource_limits:
            listener:
              egress_https:
                connection_limit: 1000
